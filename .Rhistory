rm(list=ls())
# Super Learner libraries
SL.library <- c("SL.glm","SL.step","SL.step.interaction","SL.glm.interaction","SL.gam") #"SL.randomForest","SL.glmnet"
# Data generation A: dual misspecification for the model of the outcome and treatment
set.seed(7777)
generateData <- function(n){
w1 <- round(runif(n, min=1, max=5), digits=0)
w2 <- rbinom(n, size=1, prob=0.45)
w3 <- round(runif(n, min=0, max=1), digits=0 + 0.75*w2 + 0.8*w1)
w4 <- round(runif(n, min=0, max=1), digits=0 + 0.75*w2 + 0.2*w1)
A  <- rbinom(n, size=1, prob= plogis(-1 -  0.15*w4 + 1.5*w2 + 0.75*w3 + 0.25*w1 + 0.8*w2*w4))
# Counterfactuals
Y.1 <- rbinom(n, size=1, prob = plogis(-3 + 1 + 0.25*w4 + 0.75*w3 + 0.8*w2*w4 + 0.05*w1))
Y.0 <- rbinom(n, size=1, prob = plogis(-3 + 0 + 0.25*w4 + 0.75*w3 + 0.8*w2*w4 + 0.05*w1))
# Observed outcome
Y <- Y.1*A + Y.0*(1 - A)
# return data.frame
data.frame(w1, w2, w3, w4, A, Y, Y.1, Y.0)
}
ObsDataTrueATE <- generateData(n=5000000)
True_ATE <- mean(ObsDataTrueATE$Y.1 - ObsDataTrueATE$Y.0);True_ATE
True_EY.1 <- mean(ObsDataTrueATE$Y.1)
True_EY.0 <- mean(ObsDataTrueATE$Y.0)
True_RR <- (True_EY.1 / True_EY.0);True_RR
library(tmle)
library(SuperLearner)
#install.packages("dbarts")
R <- 5
#Empty vectors
naive_RR <- rep(NA,R)
ATEtmle1 <- rep(NA,R)
RRtmle1 <- rep(NA,R)
ATE_AIPTW   <- rep(NA,R)
RR_AIPTW <- rep(NA,R)
ATEtmle2 <- rep(NA,R)
RRtmle2 <- rep(NA,R)
ATEtmle3 <- rep(NA,R)
RRtmle3 <- rep(NA,R)
for(r in 1:R){
print(paste("This is simulation run number",r))
CancerData <- generateData(n=1000)
# ATE naive approach
naive_RR[r] <- exp(glm(data = CancerData, Y ~ A + w1 + w2 + w3 + w4,  family = poisson(link="log"))$coef[2])
# TMLE implementation by hand
# Step 1
gm <- glm(Y ~ A + w1 + w2 + w3 + w4, family="binomial", data=CancerData)
# Prediction for A, A=1 and, A=0
QAW <- predict(gm)
Q1W = predict(gm, newdata=data.frame(A = 1, CancerData[,c("w1","w2","w3","w4")]))
Q0W = predict(gm, newdata=data.frame(A = 0, CancerData[,c("w1","w2","w3","w4")]))
# Step 2 estimation of the propensity score (ps)
psm <- glm(A ~ w1 + w2 + w3 + w4, family = binomial, data=CancerData)
gW = predict(psm, type = "response")
g1W = (1 / gW)
g0W = (-1 / (1-gW))
# Step 3 computation of H and estimation of epsilon
HAW <- (CancerData$A / gW -(1-CancerData$A) / (1 - gW))
H1W = (1/gW)
H0W = (-1 / (1 - gW))
epsilon <- coef(glm(CancerData$Y ~ -1 + HAW + offset(QAW), family = "binomial"))
# Step 4 updated ATE
ATEtmle1[r] <- mean(plogis(Q1W + epsilon * H1W) - plogis(Q0W + epsilon * H0W))
# Step 5 updated MOR
T1.EY1 <- mean(plogis(Q1W + epsilon * H1W))
T1.EY0 <- mean(plogis(Q0W + epsilon * H0W))
RRtmle1[r] <- (T1.EY1 / T1.EY0)
# Augmented inverse probability treatment weight (AIPTW) estimator
ATE_AIPTW[r] <- mean((HAW*(CancerData$Y - plogis(QAW)) + (plogis(Q1W)-plogis(Q0W))))
AIPTW1 <- mean(CancerData$A * (CancerData$Y - plogis(Q1W)) / gW + plogis(Q1W) )
AIPTW0 <- mean((1- CancerData$A) * (CancerData$Y - plogis(Q0W)) / (1-gW) + plogis(Q0W))
RR_AIPTW[r] <- mean( AIPTW1 / AIPTW0)
# R-package tmle (base implementation includes SL.step, SL.glm and SL.glm.interaction)
ATE2 <- tmle(Y=CancerData$Y, A=CancerData$A, W=CancerData[,c("w1","w2","w3","w4")], family="binomial")
ATEtmle2[r] <- ATE2$estimates$ATE$psi
RRtmle2[r] <- ATE2$estimates$RR$psi
# Improved Super learner
ATE3 <- tmle(Y = CancerData$Y, A=CancerData$A, W=CancerData[,c("w1","w2","w3","w4")], family="binomial", Q.SL.library=SL.library, g.SL.library=SL.library)
ATEtmle3[r] <- ATE3$estimates$ATE$psi
RRtmle3[r] <- ATE3$estimates$RR$psi
}
# Mean naive
mean(naive_RR)
# Mean AIPTW
mean(ATE_AIPTW)
mean(RR_AIPTW)
# Estimate of TMLE
mean(ATEtmle1)
mean(RRtmle1)
# Estimate of TMLE + SL
mean(ATEtmle2)
mean(RRtmle2)
# Estimate of TMLE + SL2
mean(ATEtmle3)
mean(RRtmle3)
R <- 1000
#Empty vectors
naive_RR <- rep(NA,R)
ATEtmle1 <- rep(NA,R)
RRtmle1 <- rep(NA,R)
ATE_AIPTW   <- rep(NA,R)
RR_AIPTW <- rep(NA,R)
ATEtmle2 <- rep(NA,R)
RRtmle2 <- rep(NA,R)
ATEtmle3 <- rep(NA,R)
RRtmle3 <- rep(NA,R)
for(r in 1:R){
print(paste("This is simulation run number",r))
CancerData <- generateData(n=1000)
# ATE naive approach
naive_RR[r] <- exp(glm(data = CancerData, Y ~ A + w1 + w2 + w3 + w4,  family = poisson(link="log"))$coef[2])
# TMLE implementation by hand
# Step 1
gm <- glm(Y ~ A + w1 + w2 + w3 + w4, family="binomial", data=CancerData)
# Prediction for A, A=1 and, A=0
QAW <- predict(gm)
Q1W = predict(gm, newdata=data.frame(A = 1, CancerData[,c("w1","w2","w3","w4")]))
Q0W = predict(gm, newdata=data.frame(A = 0, CancerData[,c("w1","w2","w3","w4")]))
# Step 2 estimation of the propensity score (ps)
psm <- glm(A ~ w1 + w2 + w3 + w4, family = binomial, data=CancerData)
gW = predict(psm, type = "response")
g1W = (1 / gW)
g0W = (-1 / (1-gW))
# Step 3 computation of H and estimation of epsilon
HAW <- (CancerData$A / gW -(1-CancerData$A) / (1 - gW))
H1W = (1/gW)
H0W = (-1 / (1 - gW))
epsilon <- coef(glm(CancerData$Y ~ -1 + HAW + offset(QAW), family = "binomial"))
# Step 4 updated ATE
ATEtmle1[r] <- mean(plogis(Q1W + epsilon * H1W) - plogis(Q0W + epsilon * H0W))
# Step 5 updated MOR
T1.EY1 <- mean(plogis(Q1W + epsilon * H1W))
T1.EY0 <- mean(plogis(Q0W + epsilon * H0W))
RRtmle1[r] <- (T1.EY1 / T1.EY0)
# Augmented inverse probability treatment weight (AIPTW) estimator
ATE_AIPTW[r] <- mean((HAW*(CancerData$Y - plogis(QAW)) + (plogis(Q1W)-plogis(Q0W))))
AIPTW1 <- mean(CancerData$A * (CancerData$Y - plogis(Q1W)) / gW + plogis(Q1W) )
AIPTW0 <- mean((1- CancerData$A) * (CancerData$Y - plogis(Q0W)) / (1-gW) + plogis(Q0W))
RR_AIPTW[r] <- mean( AIPTW1 / AIPTW0)
# R-package tmle (base implementation includes SL.step, SL.glm and SL.glm.interaction)
ATE2 <- tmle(Y=CancerData$Y, A=CancerData$A, W=CancerData[,c("w1","w2","w3","w4")], family="binomial")
ATEtmle2[r] <- ATE2$estimates$ATE$psi
RRtmle2[r] <- ATE2$estimates$RR$psi
# Improved Super learner
ATE3 <- tmle(Y = CancerData$Y, A=CancerData$A, W=CancerData[,c("w1","w2","w3","w4")], family="binomial", Q.SL.library=SL.library, g.SL.library=SL.library)
ATEtmle3[r] <- ATE3$estimates$ATE$psi
RRtmle3[r] <- ATE3$estimates$RR$psi
}
# Mean naive
mean(naive_RR)
# Mean AIPTW
mean(ATE_AIPTW)
mean(RR_AIPTW)
# Estimate of TMLE by hand
mean(ATEtmle1)
mean(RRtmle1)
# Estimate of TMLE + SL default implementation
mean(ATEtmle2)
mean(RRtmle2)
# Estimate of TMLE + SL2 default plus more algorithms
mean(ATEtmle3)
mean(RRtmle3)
save.image("your path\results.RData")
True_ATE <- mean(ObsDataTrueATE$Y.1 - ObsDataTrueATE$Y.0);True_ATE
True_RR <- (True_EY.1 / True_EY.0);True_RR
(True_ATE - ATE_AIPTW) / True_ATE
mean((True_ATE - ATE_AIPTW) / True_ATE)*100
abs(mean((True_ATE - ATE_AIPTW) / True_ATE)*100)
abs(mean((True_ATE - ATE_tmle1) / True_ATE)*100)
abs(mean((True_ATE - ATEtmle1) / True_ATE)*100)
abs(mean((True_ATE - ATEtmle2) / True_ATE)*100)
abs(mean((True_ATE - ATEtmle3) / True_ATE)*100)
abs(mean((True_RR - ATE_AIPTW) / True_RR)*100)
abs(mean((True_RR - ATEtmle1) / True_RR)*100)
abs(mean((True_RR - ATEtmle2) / True_RR)*100)
abs(mean((True_RR - ATEtmle3) / True_RR)*100)
abs(mean((True_RR - RR_AIPTW) / True_RR)*100)
abs(mean((True_RR - RRtmle1) / True_RR)*100)
abs(mean((True_RR - RRtmle2) / True_RR)*100)
abs(mean((True_RR - RRtmle3) / True_RR)*100)
abs(mean((True_RR - naive_RR) / True_RR)*100)
abs(mean((True_RR - RR_AIPTW) / True_RR)*100)
abs(mean((True_RR - RRtmle1) / True_RR)*100)
abs(mean((True_RR - RRtmle2) / True_RR)*100)
abs(mean((True_RR - RRtmle3) / True_RR)*100)
exit
